
/*
 * Dependencies
 */

(function() {
  var Config, Downloader, STATE_BUILDING, STATE_CLEANINGUP, STATE_CONFIGURING, STATE_MAKINGTEST, STATE_PREPARING, STATE_READY, STATE_TESTING, Utils, dfd, exec, fs, glob, mkdirp, path, rimraf;

  Config = require('./config');

  Downloader = require('./downloader');

  Utils = require('./utils');

  path = require('path');

  exec = require('child_process').exec;

  dfd = require('jquery-deferred').Deferred;

  mkdirp = require('mkdirp');

  rimraf = require('rimraf');

  fs = require('fs');

  glob = require('glob');


  /*
   * States
   */

  STATE_READY = 0;

  STATE_CONFIGURING = 1;

  STATE_PREPARING = 2;

  STATE_BUILDING = 3;

  STATE_MAKINGTEST = 4;

  STATE_TESTING = 5;

  STATE_CLEANINGUP = 6;


  /*
   * Snapshot definition
   */

  module.exports = {

    /*
    	 * Properties
     */
    prepared: false,
    state: STATE_READY,
    outputFileName: 'snapshot.bin',
    outputFilePath: null,
    execTimeout: null,
    aborted: false,
    tries: 0,

    /*
    	 * Configures the snapshot object for building and testing.
    	 * NOTE: data.appSourceNw is a zip archive containing all files needed 
    	 * to run the app (usually called app.nw). That is all assets and package.json.
    	 *
    	 * @param {Object} data
    	 * @returns {Promise}
    	 * @api public
     */
    config: function(data) {
      var err;
      this.configurationDeferred = dfd();
      if (this.state !== STATE_READY) {
        err = new Error("Build currently in process, please wait for it to complete, or send the 'abort' event.");
        this.configurationDeferred.rejectWith(this, [err]);
      }
      this.state = STATE_CONFIGURING;
      if (!(data.nwVersion && data.snapshotSource && data.appSourceNw)) {
        err = new Error("Insufficient information, you must supply nwVersion, snapshotSource, appSourceNw.");
        this.resetState();
        this.configurationDeferred.rejectWith(this, [err]);
      }
      if (data.iterations == null) {
        data.iterations = 1;
      }
      this.nwVersion = data.nwVersion, this.snapshotSource = data.snapshotSource, this.appSourceNw = data.appSourceNw, this.iterations = data.iterations;
      this.prepared = false;
      this.configurationDeferred.resolveWith(this);
      return this.configurationDeferred.promise();
    },

    /*
    	 * Prepares the specified node-webkit version for compiling the snapshot.
    	 *
    	 * @returns {Promise}
    	 * @api private
     */
    prepare: function() {
      this.state = STATE_PREPARING;
      this.preparationDeferred = dfd();
      this.download().then(this.makeTestDirectory).then(this.extractSource).done(function() {
        return this.preparationDeferred.resolveWith(this);
      }).fail(function(err) {
        return this.preparationDeferred.rejectWith(this, [err, this.tries]);
      });
      return this.preparationDeferred.promise();
    },

    /*
    	 * Extracts the application source code to the test directory, and
    	 * patches the package.json file to make use of the snapshot.
    	 *
    	 * @returns {Promise}
    	 * @api private
     */
    extractSource: function() {
      this.state = STATE_PREPARING;
      this.extractDeferred = dfd();
      mkdirp(path.join(this.testdir, 'src'), (function(_this) {
        return function(err) {
          var zipLocation;
          zipLocation = path.join(_this.testdir, 'src', 'app.zip');
          return fs.writeFile(zipLocation, _this.appSourceNw, 'binary', function(err) {
            if (!_this.checkState(_this.extractDeferred, STATE_PREPARING, err)) {
              return;
            }
            return Utils.unzip(zipLocation, path.join(_this.testdir, 'src')).done(function() {
              var packageJson, packagePath;
              packagePath = path.join(_this.testdir, 'src', 'package.json');
              packageJson = JSON.parse(fs.readFileSync(packagePath));
              packageJson.snapshot = _this.outputFileName;
              return fs.writeFile(packagePath, JSON.stringify(packageJson), function(err) {
                if (!_this.checkState(_this.extractDeferred, STATE_PREPARING, err)) {
                  return;
                }
                return _this.extractDeferred.resolveWith(_this);
              });
            }).fail(function(err) {
              return _this.extractDeferred.rejectWith(_this, [err]);
            });
          });
        };
      })(this));
      return this.extractDeferred.promise();
    },

    /*
    	 * Downloads the specified node-webkit version.
    	 *
    	 * @returns {Promise}
    	 * @api private
     */
    download: function() {
      var downloadPromise, downloader;
      this.downloadDeferred = dfd();
      downloader = new Downloader(this.nwVersion);
      downloadPromise = downloader.ensure();
      downloadPromise.done((function(_this) {
        return function(snapshotterPath, nwPath) {
          _this.snapshotterPath = snapshotterPath;
          _this.nwPath = nwPath;
          if (_this.checkState(_this.preparationDeferred, STATE_PREPARING)) {
            _this.prepared = true;
            return _this.downloadDeferred.resolveWith(_this);
          }
        };
      })(this));
      downloadPromise.fail((function(_this) {
        return function(err) {
          _this.resetState();
          return _this.downloadDeferred.rejectWith(_this, [err]);
        };
      })(this));
      return this.downloadDeferred.promise();
    },

    /*
    	 * Creates the test directory with application files.
    	 *
    	 * @returns {Promise}
    	 * @api private
     */
    makeTestDirectory: function() {
      this.makeDeferred = dfd();
      this.state = STATE_MAKINGTEST;
      this.testdir = path.join(__dirname, '..', "tmp", new Date().getTime() + "");
      mkdirp(this.testdir, (function(_this) {
        return function(err) {
          if (!_this.checkState(_this.makeDeferred, STATE_MAKINGTEST, err)) {
            return;
          }
          return _this.makeDeferred.resolveWith(_this, [_this.testdir]);
        };
      })(this));
      return this.makeDeferred.promise();
    },

    /*
    	 * Patches the snapshot source code with the build callback function.
    	 * The callback function is supposed to be invoked from the main .html file.
    	 * This is done to test the validity of the snapshot, to make sure it works.
    	 *
    	 * @returns {Promise}
    	 * @api private
     */
    patchSource: function() {
      var callbackCode;
      this.patchDeferred = dfd();
      this.state = STATE_BUILDING;
      this.id = new Date().getTime() + '_' + Math.round(Math.random() * (1000 - 1) + 1);
      callbackCode = "// callback for build testing\nvar __buildcallbackWrapper = function() {\n	callbackArgIndex = require('nw.gui').App.argv.indexOf('--" + this.id + "');\n	if (callbackArgIndex > -1) {\n		url = \"" + Config.callbackURL + "/" + this.id + "\"\n		script = document.createElement('script');\n		script.src = url;\n		script.onload = function(){\n			process.exit();\n		};\n		document.querySelector('body').appendChild(script);\n	}\n}";
      fs.writeFile(path.join(this.testdir, 'snapshot.js'), this.snapshotSource.toString() + callbackCode, (function(_this) {
        return function(err) {
          if (!_this.checkState(_this.patchDeferred, STATE_BUILDING, err)) {
            return;
          }
          return _this.patchDeferred.resolveWith(_this);
        };
      })(this));
      return this.patchDeferred.promise();
    },

    /*
    	 * Compiles the snapshot.
    	 *
    	 * @returns {Promise}
    	 * @api private
     */
    compile: function() {
      this.state = STATE_BUILDING;
      this.buildDeferred = dfd();
      this.outputFilePath = path.join(this.testdir, this.outputFileName);
      this.testFilePath = path.join(this.testdir, 'src', path.basename(this.outputFileName));
      this.patchSource().done(function() {
        return exec("" + this.snapshotterPath + " --extra_code " + (path.join(this.testdir, 'snapshot.js')) + " " + this.outputFilePath, (function(_this) {
          return function(err) {
            if (_this.checkState(_this.buildDeferred, STATE_BUILDING, err)) {
              return fs.readFile(_this.outputFilePath, 'binary', function(err, data) {
                if (!_this.checkState(_this.buildDeferred, STATE_BUILDING, err)) {
                  return;
                }
                return fs.writeFile(_this.testFilePath, data, 'binary', function(err) {
                  if (!_this.checkState(_this.buildDeferred, STATE_BUILDING, err)) {
                    return;
                  }
                  return _this.buildDeferred.resolveWith(_this);
                });
              });
            }
          };
        })(this));
      }).fail(function(err) {
        return this.buildDeferred.rejectWith(this, [err]);
      });
      return this.buildDeferred.promise();
    },

    /*
    	 * Starts an iteration which will compile and test the snapshot.
    	 *
    	 * @returns {Promise}
    	 * @api private
     */
    iterate: function() {
      this.iterations--;
      return this.compile().then(this.test);
    },

    /*
    	 * Starts the snapshotter.
    	 *
    	 * @returns {Promise}
    	 * @api public
     */
    run: function() {
      var doneFilter, failFilter, filters;
      this.tries = 0;
      this.runDeferred = dfd();
      if (!this.prepared) {
        this.runDeferred.rejectWith(this, [new Error("You need to run prepare() first!")]);
        return this.runDeferred.promise();
      }
      doneFilter = function() {};
      failFilter = function(err) {
        this.tries++;
        this.runDeferred.notifyWith(this, [err, this.tries]);
        this.cleanupSnapshot();
        if (this.iterations > 0) {
          return this.iterate().then.apply(this, filters);
        } else {
          return err;
        }
      };
      filters = [doneFilter, failFilter];
      this.iterate().then.apply(this, filters).done(function() {
        var fileBuffer;
        fileBuffer = fs.readFileSync(this.outputFilePath);
        return this.cleanupTest().always(function() {
          this.runDeferred.resolveWith(this, [fileBuffer, this.tries]);
          return this.resetState();
        });
      }).fail(function(err) {
        return this.cleanupTest().always(function() {
          this.runDeferred.rejectWith(this, [err, this.tries]);
          return this.resetState();
        });
      });
      return this.runDeferred.promise();
    },

    /*
    	 * Checks if the snapshotter is in the correct state or if we need to abort.
    	 * An error object can be supplied for convenience when checking in callbacks.
    	 *
    	 * @param {Deferred} deferred.
    	 * @param {Integer} expectedState
    	 * @param {Error} err 
    	 * @returns {Boolean}
    	 * @api private
     */
    checkState: function(deferred, expectedState, err) {
      if (err == null) {
        err = null;
      }
      if (err) {
        deferred.rejectWith(this, [err]);
        return false;
      }
      if (this.state !== expectedState) {
        err = new Error("State mismatch. State was " + this.state + " expecting " + expectedState + ".");
        deferred.rejectWith(this, [err]);
        return false;
      }
      if (this.aborted) {
        deferred.rejectWith(this, [new Error('Aborted!')]);
        return false;
      }
      return true;
    },

    /*
    	 * Cleans up (deletes) the test directory.
    	 *
    	 * @returns {Promise}
    	 * @api private
     */
    cleanupTest: function() {
      this.state = STATE_CLEANINGUP;
      this.cleanupDeferred = dfd();
      rimraf(this.testdir, (function(_this) {
        return function(err) {
          if (err) {
            return _this.cleanupDeferred.rejectWith(_this, [err]);
          }
          return glob("**/*v8.log", function(err, files) {
            var e, file, _i, _len;
            if (err) {
              return _this.cleanupDeferred.rejectWith(_this, [err]);
            }
            for (_i = 0, _len = files.length; _i < _len; _i++) {
              file = files[_i];
              try {
                fs.unlinkSync(file);
              } catch (_error) {
                e = _error;
                return _this.cleanupDeferred.rejectWith(_this, [e]);
              }
            }
            return _this.cleanupDeferred.resolveWith(_this);
          });
        };
      })(this));
      return this.cleanupDeferred.promise();
    },

    /*
    	 * Cleans up (deletes) the compiled snapshot.
    	 *
    	 * @returns {Boolean} result of unlink.
    	 * @api private
     */
    cleanupSnapshot: function() {
      if (fs.existsSync(this.outputFilePath)) {
        return fs.unlinkSync(this.outputFilePath);
      }
    },

    /*
    	 * Notifies the snapshotter when the app has launced succesfully.
    	 * This method should be called from the server when the callback URL is requested.
    	 * Calling this method will immediately kill the app, as it's no longer needed.
    	 *
    	 * @returns {Boolean} always true. 
    	 * @api public
     */
    notify: function(id) {
      if (this.id === id) {
        this.didNotify = true;
        this.killProcess();
      }
      return true;
    },
    killProcess: function() {
      if (Config.platform === 'win') {
        exec("taskkill /pid " + this.process.pid + " /f");
        try {
          this.process.kill('SIGKILL');
          this.process.kill('SIGTERM');
          this.process.kill('SIGHUP');
          this.process.kill();
          return this.process.exit();
        } catch (_error) {

        }
      } else {
        return this.process.kill();
      }
    },

    /*
    	 * Launces the app with the compiled snapshot. 
    	 * NOTE: patchSource/compile has to be run first to generate an id and callback code.
    	 *
    	 * @returns {Promise}
    	 * @api private
     */
    launch: function() {
      var exePath;
      this.state = STATE_TESTING;
      this.launchDeferred = dfd();
      this.didNotify = false;
      if (!this.id) {
        this.launchDeferred.rejectWith(this, [new Error("Can't launch the test without a test id. See @compile() and @patchSource().")]);
      }
      exePath = path.join(this.testdir, 'src');
      this.process = exec("" + this.nwPath + " \"--" + this.id + "\" " + exePath);
      this.execTimeout = setTimeout((function(_this) {
        return function() {
          _this.killProcess();
          return _this.launchDeferred.rejectWith(_this, [new Error("Timeout in testing after " + Config.timeout + "ms.")]);
        };
      })(this), Config.timeout);
      this.process.on('exit', (function(_this) {
        return function() {
          if (_this.didNotify) {
            _this.launchDeferred.resolveWith(_this);
            return _this.didNotify = false;
          } else {
            clearTimeout(_this.execTimeout);
            return _this.launchDeferred.rejectWith(_this, [new Error("Process exited without calling back. Probably just another bad snapshot. \nCould also be that you are not calling __buildcallbackWrapper() from your main html file.")]);
          }
        };
      })(this));
      return this.launchDeferred.promise();
    },

    /*
    	 * Tests the compiled snapshot.
    	 *
    	 * @returns {Promise}
    	 * @api private
     */
    test: function() {
      this.testDeferred = dfd();
      this.launch().fail(function(err) {
        this.cleanupSnapshot();
        return this.testDeferred.rejectWith(this, [err]);
      }).done(function() {
        return this.testDeferred.resolveWith(this);
      });
      return this.testDeferred.promise();
    },

    /*
    	 * Resets the snapshotter object's state.
    	 *
    	 * @returns {Boolean} always true
    	 * @api private
     */
    resetState: function() {
      this.aborted = false;
      this.prepared = false;
      this.state = STATE_READY;
      return true;
    },

    /*
    	 * Calls resetState and resolves the abortDeferred.
    	 *
    	 * @returns {Deferred}
    	 * @api private
     */
    resetStateAndResolve: function() {
      this.resetState();
      return this.abortDeferred.resolveWith(this);
    },

    /*
    	 * Aborts current process, and properly cleans up.
    	 * This method is called from the server when an 'abort' event is recieved.
    	 *
    	 * @returns {Promise}
    	 * @api public
     */
    abort: function() {
      console.log('abort!');
      this.abortDeferred = dfd();
      this.aborted = true;
      switch (this.state) {
        case STATE_READY:
          this.resetStateAndResolve();
          break;
        case STATE_CONFIGURING:
          this.configurationDeferred.always(this.resetStateAndResolve);
          break;
        case STATE_PREPARING:
          this.preparationDeferred.always(this.resetStateAndResolve);
          break;
        case STATE_BUILDING:
          this.buildDeferred.always(this.resetStateAndResolve);
          break;
        case STATE_MAKINGTEST:
          this.makeDeferred.always(this.resetStateAndResolve);
          break;
        case STATE_TESTING:
          this.launchDeferred.always(this.resetStateAndResolve);
          this.killProcess();
      }
      return this.abortDeferred.promise();
    }
  };

}).call(this);
